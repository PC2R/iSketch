\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{fullpage}
\usepackage{graphicx}

\title{Devoir de programmation PC2R : iSketch}
\author{Clara \bsc{Muller} \& Théo \bsc{Lebourg}}
\date{}

\begin{document}

\maketitle

\section{Côté serveur}
Pour développer la partie serveur de iSketch, nous avons opté pour le
langage OCaml. Nous allons dans un premier temps expliquer quels ont
été nos choix pour organiser notre serveur avant de s’attarder un peu
plus en détail sur le code.

\subsection {Lancement du serveur et de la partie}
Lorsque l'exécutable est lancé avec les paramètres qui vont bien, la
première étape du programme est la création du serveur (pour qu’il
soit prêt à recevoir les connexions des futurs clients) ainsi que
l’initialisation de certaines variables qui seront utilisées une fois
le jeu lancé.

\bigskip La création de notre objet serveur reprend les étapes
classiques vues en cours : on crée une \textbf{une prise} (en
utilisant le domaine Internet, le flot d’octets et le protocole de
communication par défaut) et on récupère \textbf{une adresse dans le
  domaine internet} (à l’aide de l’adresse Internet de la machine
locale et d’un numéro de port défini par l’utilisateur) afin de
pouvoir associer les deux, puis on rend la prise capable d’accepter
les connexions et enfin, on met en place une boucle infinie qui
accepte les demandes de connexions et qui va créer un thread joueur à
chaque nouvelle demande (nous verrons plus tard comment nous gérons le
nombre limite de joueurs par partie).

Notons qu’avant de commencer à accepter les demandes de connexion,
nous lisons le fichier dictionnaire et nous stockons dans une liste
chacun des mots présent dans le fichier. Nous avons opté pour cette
solution pour éviter de devoir ouvrir et fermer le dictionnaire à
chaque tour de round pour piocher un mot. 

\bigskip En parallèle des demandes de connexions des joueurs, on lance
un thread qui va commencer par attendre que tous les joueurs soient
connectés. Une fois cette condition remplie, le premier round
s’exécute : un mot est choisi (et retiré de la liste pour éviter de le
tirer plus tard) ainsi qu’un dessinateur et ces informations sont
envoyées à tous les joueurs via la commande \verb+NEW_ROUND+. Ensuite,
le serveur attend cette fois-ci qu’un mot soit trouvé et une fois
cette condition remplie, il envoie à tous les joueurs les commandes
\verb+END_ROUND+ et \verb+SCORE_ROUND+ qui donnent respectivement le
nom du vainqueur et le mot qu’il fallait trouver et le score de tous
les joueurs. Enfin, un nouveau round peut commencer en suivant le même
schéma qui vient d’être décrit.

\subsection {Connexion d’un joueur}

Plusieurs possibilités sont offertes au joueur pour accéder au jeu :
\bigskip
\begin{itemize}
\item Avec la commande \verb+CONNECT/user/+ : le serveur vérifie alors
  que le nom \textit{user} n’a pas déjà été choisi (en vérifiant la
  base de données des comptes utilisateurs ainsi que les joueurs déjà
  connectés à la partie en cours) et crée un nouveau nom si ce n’est
  pas le cas (en concaténant un nombre à la fin de \textit{user}).
\item Avec la commande \verb+REGISTER/user/password/+ : le serveur
  vérifie alors que le nom \textit{user} n’a pas déjà été choisi et
  l’ajoute à la base de données si c’est le cas.
\item Avec la commande \verb+LOGIN/user/password/+ : le serveur
  vérifie alors que les noms \textit{user} et \textit{password} sont
  corrects et s’ils le sont, le serveur vérifie également que le
  joueur n’est pas déjà en train de jouer.
\end{itemize}
\bigskip Enfin, notons qu’une commande \verb+ACCESSDENIED/+ est
envoyée ou bien si le nombre maximum de joueurs pour une partie est
atteint ou bien si les noms et mots de passe ne correspondent pas ou
bien si un joueur tente de se connecter alors qu’il est déjà connecté.

\subsubsection {Quand un mot est trouvé par un joueur}

Voici le déroulement général des étapes effectuées par le serveur
lorsqu’un joueur a trouvé le mot que le dessinateur était en train de
dessiner. Notons que puisque les joueurs évoluent chacun sur un
thread, nous avons protégé cette série d’opérations par un
\textbf{mutex}.

\begin{enumerate}
\item Le serveur se charge d’envoyer la commande
  \verb+WORD_FOUND/joueur/+ à tous les joueurs de la partie.
\item Le serveur attribue le nombre de points qui va bien au joueur
  qui a trouvé le mot
\item Un timeout est lancé si et seulement si le joueur en question
  est le premier à trouver le mot et il reste des joueurs connectés
  (sinon, s’il est le seul, alors un nouveau round peut commencer si
  la partie n’est pas terminée)
\end{enumerate}

\subsection {Extensions}

\subsubsection{Discussion instantanée}

La mise en place de la discussion instantanée côté serveur n’a pas
été trop compliquée étant donné qu’il suffit de récupérer la chaîne de
caractère contenue dans la commande \verb+TALK+ pour la renvoyer à
tous les joueurs via la commande \verb+LISTEN+. Par ailleurs, comme
suggéré dans l’énoncé, nous avons utilisé la commande
\verb+BROADCAST+ pour annoncer à tous les joueurs qu’un acte de triche
avait été signalé par l’un d’entre eux.

\subsubsection {Comptes utilisateurs}

Côté serveur, nous avons opté pour le stockage des noms et mots de
passe des joueurs dans un simple fichier texte. Cependant, avant
d'être stocké sur ce fichier, le mot de passe est salé (dynamiquement
pour éviter les attaques par tables arc-en-ciel) puis hashé avec la
fonction de hashage MD5 (cette fonction de hachage n'est certes plus
fiable depuis longtemps mais nous n’avons pas trouvé dans la librairie
standard d'OCaml d’autres fonctions plus performantes telle SHA-256).
Ainsi, à chaque inscription, on ajoute une ligne contenant le nom du
joueur, le mot de passé hashé et salé et le sel.

\bigskip Par ailleurs, notons que pour l’instant, les mots de passe
circulent en clair lorsqu’ils sont envoyés depuis le client.

\subsubsection {Serveur HTTP de statistiques}

Afin de rendre les statistiques de iSketch (nombre de parties gagnées
et perdues pour les joueurs enregistrés dans la base de données)
disponibles via un navigateur internet, nous avons repris la base de
notre serveur acceptant les connexions des joueurs mais en fixant
cette fois-ci le port 2092 comme énoncé dans le sujet. Il nous a
ensuite fallu trouver le moyen de répondre aux requêtes \verb+GET+ du
navigateur envoyées lorsque le joueur entre l’URL
\textit{adresse\_du\_serveur:2092}. Pour cela, lorsque nous recevons
une requête \verb+GET+ (de la forme \textit{GET / HTTP/protocole})
nous commençons par récupérer le protocole pour construire notre
requête qui sera construite de la manière suivante : une première
ligne de la forme \textit{HTTP/protocole 200 OK}, suivie de quelques
headers, une ligne vide et enfin notre page HTML contenant les
informations des joueurs.

\bigskip Par ailleurs, nous avons muni la page HTML d’une balise qui
permet le rafraîchissement de la page toutes les minutes pour ainsi
actualiser les statistiques.

\section{Côté client}

\end{document}
